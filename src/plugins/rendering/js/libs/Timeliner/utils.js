/* eslint-disable no-unused-vars */
/* eslint-disable camelcase */
/* eslint-disable no-tabs */

// module.exports = {
//   STORAGE_PREFIX: 'timeliner-',
//   Z_INDEX: 999,
//   style: style,
//   saveToFile: saveToFile,
//   openAs: openAs,
//   format_friendly_seconds: format_friendly_seconds,
//   proxy_ctx: proxy_ctx,
//   handleDrag: handleDrag,
//   binarySearch: binarySearch
// }

/**************************/
// Utils
/**************************/

function binarySearch (arr, num) {
  var l = 0; var r = arr.length; var found = false

  while (l < r) {
    var m = (l + r) >> 1

    if (arr[m] < num) {
      l = m + 1
    } else {
      r = m

      found = arr[m] === num
    }
  }

  return found ? l : ~l
}

function handleDrag (element, ondown, onmove, onup, down_criteria) {
  var pointer = null
  var bounds = element.getBoundingClientRect()

  element.addEventListener('mousedown', onMouseDown)

  function onMouseDown (e) {
    handleStart(e)

    if (down_criteria && !down_criteria(pointer, e)) {
      pointer = null
      return
    }

    document.addEventListener('mousemove', onMouseMove)
    document.addEventListener('mouseup', onMouseUp)

    ondown(pointer, e)

    e.preventDefault()
  }

  function onMouseMove (e) {
    handleMove(e)
    pointer.moved = true
    onmove(pointer, e)
  }

  function handleStart (e) {
    bounds = element.getBoundingClientRect()
    var currentx = e.clientX; var currenty = e.clientY
    pointer = {
      startx: currentx,
      starty: currenty,
      x: currentx,
      y: currenty,
      dx: 0,
      dy: 0,
      offsetx: currentx - bounds.left,
      offsety: currenty - bounds.top,
      moved: false
    }
  }

  function handleMove (e) {
    bounds = element.getBoundingClientRect()
    var currentx = e.clientX
    var currenty = e.clientY
    var offsetx = currentx - bounds.left
    var offsety = currenty - bounds.top
    pointer.x = currentx
    pointer.y = currenty
    pointer.dx = e.clientX - pointer.startx
    pointer.dy = e.clientY - pointer.starty
    pointer.offsetx = offsetx
    pointer.offsety = offsety
  }

  function onMouseUp (e) {
    handleMove(e)
    onup(pointer, e)
    pointer = null

    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', onMouseUp)
  }

  element.addEventListener('touchstart', onTouchStart)

  function onTouchStart (te) {
    if (te.touches.length === 1) {
      var e = te.touches[0]
      if (down_criteria && !down_criteria(e)) return
      te.preventDefault()
      handleStart(e)
      ondown(pointer, e)
    }

    element.addEventListener('touchmove', onTouchMove)
    element.addEventListener('touchend', onTouchEnd)
  }

  function onTouchMove (te) {
    var e = te.touches[0]
    onMouseMove(e)
  }

  function onTouchEnd (e) {
    // var e = e.touches[0];
    onMouseUp(e)
    element.removeEventListener('touchmove', onTouchMove)
    element.removeEventListener('touchend', onTouchEnd)
  }

  function release () {
    element.removeEventListener('mousedown', onMouseDown)
    element.removeEventListener('touchstart', onTouchStart)
  }
}

function style (element, var_args) {
  for (var i = 1; i < arguments.length; ++i) {
    var styles = arguments[i]
    for (var s in styles) {
      element.style[s] = styles[s]
    }
  }
}

function saveToFile (string, filename) {
  var a = document.createElement('a')
  document.body.appendChild(a)
  a.style = 'display: none'

  var blob = new Blob([string], { type: 'octet/stream' }) // application/json
  var url = window.URL.createObjectURL(blob)

  a.href = url
  a.download = filename

  fakeClick(a)

  setTimeout(function () {
    // cleanup and revoke
    window.URL.revokeObjectURL(url)
    document.body.removeChild(a)
  }, 500)
}

var input, openCallback

function handleFileSelect (evt) {
  var files = evt.target.files // FileList object

  // console.log('handle file select', files.length);

  var f = files[0]
  if (!f) return
  // Can try to do MINE match
  // if (!f.type.match('application/json')) {
  //   return;
  // }
  // console.log('match', f.type);

  var reader = new FileReader()

  // Closure to capture the file information.
  reader.onload = function (e) {
    var data = e.target.result
    openCallback(data)
  }

  reader.readAsText(f)

  input.value = ''
}

function openAs (callback, target) {
  // console.log('openfile...');
  openCallback = callback

  if (!input) {
    input = document.createElement('input')
    input.style.display = 'none'
    input.type = 'file'
    input.addEventListener('change', handleFileSelect)
    target = target || document.body
    target.appendChild(input)
  }

  fakeClick(input)
}

function fakeClick (target) {
  var e = document.createEvent('MouseEvents')
  e.initMouseEvent(
    'click', true, false, window, 0, 0, 0, 0, 0,
    false, false, false, false, 0, null
  )
  target.dispatchEvent(e)
}

function format_friendly_seconds (s, type) {
  // TODO Refactor to 60fps???
  // 20 mins * 60 sec = 1080
  // 1080s * 60fps = 1080 * 60 < Number.MAX_SAFE_INTEGER

  var raw_secs = s | 0
  var secs_micro = s % 60
  var secs = raw_secs % 60
  var raw_mins = raw_secs / 60 | 0
  var mins = raw_mins % 60
  var hours = raw_mins / 60 | 0

  var secs_str = (secs / 100).toFixed(2).substring(2)

  var str = mins + ':' + secs_str

  if (s % 1 > 0) {
    var t2 = (s % 1) * 60
    if (type === 'frames') str = secs + '+' + t2.toFixed(0) + 'f'
    else str += ((s % 1).toFixed(2)).substring(1)
    // else str = mins + ':' + secs_micro;
    // else str = secs_micro + 's'; /// .toFixed(2)
  }
  return str
}

function proxy_ctx (ctx) {
  // Creates a proxy 2d context wrapper which
  // allows the fluent / chaining API.
  var wrapper = {}

  function proxy_function (c) {
    return function () {
      // Warning: this doesn't return value of function call
      ctx[c].apply(ctx, arguments)
      return wrapper
    }
  }

  function proxy_property (c) {
    return function (v) {
      ctx[c] = v
      return wrapper
    }
  }

  wrapper.run = function (args) {
    args(wrapper)
    return wrapper
  }

  for (var c in ctx) {
    // if (!ctx.hasOwnProperty(c)) continue;
    // console.log(c, typeof(ctx[c]), ctx.hasOwnProperty(c));
    // string, number, boolean, function, object

    var type = typeof (ctx[c])
    switch (type) {
      case 'object':
        break
      case 'function':
        wrapper[c] = proxy_function(c)
        break
      default:
        wrapper[c] = proxy_property(c)
        break
    }
  }

  return wrapper
}

var utils = {
  STORAGE_PREFIX: 'timeliner-',
  Z_INDEX: 999,
  style: style,
  saveToFile: saveToFile,
  openAs: openAs,
  format_friendly_seconds: format_friendly_seconds,
  proxy_ctx: proxy_ctx,
  handleDrag: handleDrag,
  binarySearch: binarySearch
}

export { utils }
